/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package clases;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer.MethodName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import clases.helpers.Aleatorios;
import clases.helpers.TesterDAO;
import negocio.vo.Persona;
import negocio.vo.RowDescriptor;
import negocio.vo.RowType;
import negocio.vo.TableDescriptor;
import negocio.vo.Tienda;
import negocio.vo.User;
import persistencia.dao.ExamenDAO;
import persistencia.dao.impl.ExamenImpl;
import persistencia.dao.impl.GenericDAOImpl;

/**
 * Esta clase esta preparada para testear el programa main principal de un proyecto
 * interceptando y suplantando tando la entrada como la salida estandar teclado
 * y pantalla
 * @author eserrano
 *
 */
@TestMethodOrder(MethodName.class)
class MainTest extends MiddleTest{
	

	private static final String OK = "OK";
	private static ExamenDAO userBD = new ExamenImpl();
	
	
	
	@Test
	@DisplayName("Compilación")
	/**
	 * Compila y se pueden establecer reglas basicas,
	 * Por ejemplo impedir la importación de ciertas clases 
	 */
	void test00RequisitosBasicos() {
		assertTrue(true);
	}
	
	@Test
	@DisplayName("Manejo de Conexiones")
	/**
	 * toString 1,5
	 */
	void test01() throws SQLException {
		print("Probando establecimiento parámetros conexión ...");
		GenericDAOImpl.setConecctionURI(C.connectionURI);
		assertEquals(C.connectionURI, GenericDAOImpl.getConecctionURI());
		GenericDAOImpl.setUser(C.user);
		assertEquals(C.user, GenericDAOImpl.getUser());
		GenericDAOImpl.setPassword(C.password);
		assertEquals(C.password, GenericDAOImpl.getPassword());
		println(OK);
		
		print("Probando a obtener conexión Compartida ...");
		Connection c = GenericDAOImpl.getConnection(false);
		Assertions.assertNotNull(c);
		DatabaseMetaData data = c.getMetaData();
		assertTrue(data.getURL().equalsIgnoreCase(C.connectionURI));
		String username = data.getUserName().split("@")[0];
		assertEquals(C.user,username);
		
		Connection c2 = GenericDAOImpl.getConnection(false);
		assertEquals(c,c2);
		println(OK);
	}
	
	@Test
	@DisplayName("Manejo de Conexiones")
	/**
	 * toString 1,5
	 */
	void test02() throws SQLException {
		print("Probando establecimiento parámetros conexión ...");
		GenericDAOImpl.setConecctionURI(C.connectionURI);
		assertEquals(C.connectionURI, GenericDAOImpl.getConecctionURI());
		GenericDAOImpl.setUser(C.user);
		assertEquals(C.user, GenericDAOImpl.getUser());
		GenericDAOImpl.setPassword(C.password);
		assertEquals(C.password, GenericDAOImpl.getPassword());
		println(OK);
				
		print("Probando a obtener conexión Individual ...");
		Connection c = GenericDAOImpl.getConnection(true);
		Assertions.assertNotNull(c);
		DatabaseMetaData data = c.getMetaData();
		assertTrue(data.getURL().equalsIgnoreCase(C.connectionURI));
		String username = data.getUserName().split("@")[0];
		assertEquals(C.user,username);
		
		Connection c2 = GenericDAOImpl.getConnection(true);
		Assertions.assertNotEquals(c,c2);
		println(OK);
		
	}
	
	@Test
	@DisplayName("Login")
	/**
	 * toString 1,5
	 */
	void test03() {
		print("Probando Login ...");
		User u = userBD.login(conexion, "Sandra", "1234");
		Assertions.assertNotNull(u);
		assertEquals("Sandra",u.getUsername());
		assertEquals("1234",u.getPassword());
		
		u = userBD.login(conexion, "Sandra", Aleatorios.cadenaAleatoria(5, 6));
		Assertions.assertNull(u);
		println(OK);
		
		print("Probando SQL Injection ...");
		Assertions.assertNull(userBD.login(conexion,"Sandra", "' OR '1'='1"));
		println(OK);
	}
	

	// 3 Hacer Insert de Objeto
	@Test
	@DisplayName("Insertar Persona tabla")
	/**
	 * toString 1,5
	 */
	void test04() throws SQLException {

		print("Probando Inserción de Persona ...");
		
		Persona p = crearPersonaAleatoria(0);
		try {
			userBD.insertaPersona(conexion, p);
			
			String consulta = "SELECT * FROM Personas "
					+ "WHERE nombre=? "
					+ "AND dni=? "
					+ "AND fecha_nacimiento=? "
					+ "AND peso=? "
					+ "AND titulado=?;";
			PreparedStatement sentencia = conexion.prepareStatement(consulta);
			sentencia.setString(1, p.getNombre());
			sentencia.setString(2, p.getDni());
			sentencia.setString(3, p.getFechaNacimiento().format(DateTimeFormatter.ofPattern("yyyy-MM-dd")));
			sentencia.setFloat(4, p.getPeso());
			sentencia.setBoolean(5, p.getTitulado());
			
			ResultSet rs = sentencia.executeQuery();
			assertTrue(rs.next());
			Assertions.assertFalse(rs.next());
		}finally {
			elimina(p);
		}
		println(OK);
	}
	
	//Consulta de  N:M y Crear objeto compuesto
	
		@Test
		@DisplayName("Consultar Tienda")
		/**
		 * toString 1,5
		 */
		void test05() throws SQLException {

			print("Recuperando Tienda ...");
			int tienda = Aleatorios.numeroAleatorio(1, 4);
			Tienda t = test04Aux(conexion,tienda);
			Tienda tf = test04AuxFalse(conexion,tienda);
			Tienda c = userBD.recuperaTienda(conexion, tienda);
			Assertions.assertNotNull(c);
			assertEquals(t, c);
			Assertions.assertNotEquals(tf,c);
			
			tienda = Aleatorios.numeroAleatorio(100, 200);
			c = userBD.recuperaTienda(conexion, tienda);
			Assertions.assertNull(c);
						
			println(OK);
		}
		
		
	
	//Actualización con Transacción
		
		@Test
		@DisplayName("Insertar Remesa de Personas")
		/**
		 * toString 1,5
		 */
		void test06() throws SQLException, InterruptedException {

			print("Probando Creación personas por lote...");
			int expected = cuentaPersonas();
			List<Persona> malas = damePersonas();
			int gato = Aleatorios.numeroAleatorio(1, malas.size()-2);
			malas.get(gato).setDni(null);
			try {
				Connection conEspec = TesterDAO.getIndividualConnection();
				userBD.insertaPersonasLote(conEspec, malas); 
				
				if(!conEspec.isClosed())
					 conEspec.close();
				
				int reales = cuentaPersonas();
				assertEquals(expected, reales);
			}finally {
				elimina(malas);
			}
			
			
			List<Persona> buenas = damePersonas();
			try {
				expected = cuentaPersonas();
				Connection conEspec = TesterDAO.getIndividualConnection();
				userBD.insertaPersonasLote(conEspec, buenas);  
				if(!conEspec.isClosed())
					 conEspec.close();

				int reales = cuentaPersonas();
				assertEquals(expected+buenas.size(), reales);
			}finally {
				elimina(buenas);
			}
			
			println(OK);
		}
		
		
		
		@Test
		@DisplayName("Crear tabla")
		/**
		 * toString 1,5
		 */
		void test07() throws SQLException {

			print("Probando Creación Tabla ...");
			var columns = Aleatorios.numeroAleatorio(3, 10);
			List<RowDescriptor> filas = new ArrayList<>();
			for(int i=1;i<columns;i++) {
				String columnName = "column_0" + i;
				RowType tipo = RowType.getByNum(Aleatorios.numeroAleatorio(0, RowType.values().length));
				RowDescriptor descriptorFila = new RowDescriptor(columnName, tipo);
				filas.add(descriptorFila);
			}
			
			String tableName = Aleatorios.cadenaAleatoria(10, 20);
			
			TableDescriptor tabla = new TableDescriptor(tableName, filas);
			try {
				userBD.createTable(conexion, tabla);
				
				PreparedStatement sentencia = conexion.prepareStatement(TesterDAO.TABLE_INFO);
				sentencia.setString(1, tableName);
				
				ResultSet rs = sentencia.executeQuery();
				int contador = 0;
				List<RowDescriptor> filasAc = new ArrayList<>();
				while(rs.next()) {
					String columnName = rs.getString("COLUMN_NAME");
					String dataType = rs.getString("DATA_TYPE");
					RowType tipo = RowType.getByName(dataType);
					RowDescriptor descriptorFila = new RowDescriptor(columnName, tipo);
					filasAc.add(descriptorFila);
					contador++;
					if(contador==1)
						assertEquals("PRI",rs.getString("COLUMN_KEY"));
				}
				
				assertEquals(filas.size(), filasAc.size());
				Assertions.assertIterableEquals(filas, filasAc);
			}finally {
				deleteTable(tableName);
			}

			println(OK);
		}
		
		int cuentaPersonas() throws SQLException {
			
			int ret = 0;
			Connection conEspec = TesterDAO.getIndividualConnection();
			Statement sentencia = conEspec.createStatement();
			
			ResultSet rs = sentencia.executeQuery("SELECT COUNT(*) FROM Personas;");
			
			if(rs.next())
				ret = rs.getInt(1);
			conEspec.close();
			return ret;
		}
		
		void elimina(List<Persona> list) {
			for (Persona persona : list)
				elimina(persona);
		}
		
		void elimina(Persona persona) {
			conexion=TesterDAO.getSharedConnection();
			try (PreparedStatement st = conexion.prepareStatement("DELETE FROM Personas WHERE dni=?;");){
				if(persona.getDni()!=null) {
						st.setString(1, persona.getDni());
						st.executeUpdate();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
		
	
	// 2 Crear una tabla con parámetros
		
	
	
	void deleteTable(String tableName) throws SQLException {
		conexion=TesterDAO.getSharedConnection();
		Statement sentencia = conexion.createStatement();
		sentencia.execute("DROP TABLE " + tableName);
	}
}